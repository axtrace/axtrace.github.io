---
Author:
  - Айла Нейштадт
  - Джим Арлоу
Date: 2023-10-08
Status: Finished
created at: 2022-06-03T23:47
Raiting: ⭐️⭐️⭐️⭐️⭐️
---
# Детали книги

Хорошо раскрывает основы UML и универсального подхода к проектированию системы.

# Перед прочтением

1. Копнуть вглубь UML 2

# После прочтения

## Предисловие

  

> [!important]  
> UP обеспечивает каркас процесса производства ПО, указывайющий, как осуществлять ОО анализ и проектирование.  

UML-инструмент, поддерживающий MDA, такой как ArcStyler (arcstyler.com)

  

## Глава 1

Унифицированный язык моделирования (Unified Modeling Language, UML) - это универсальный язык визуального моделирования систем. Открытый, принятый в качестве промышленного стандарта, одобренный OMG.

> UML не предполагает нам какой-либо методологии моделирования

Унифицированный процесс (Unified Process, Unified Software Development Process, USDP, UP) - это методология. Она указывает на исполнителей, действий и артефактов, которые необходимо использовать, осуществить или создать для моделирования программной системы.

> UP можно рассматривать как предпочтительный метод для UML, поскольку он лучше всего адаптирован к нему

По сути, UP - внедренный в практику и проверенный метод разработки программного обеспечения, объединяющий в себе лучшие качества своих предшественников

Унифицированный процесс компании Rational (Rational Unified Process, RUP) - это коммерческая версия UP от IBM, которая поглотила Rational Corporation в 2003 году.

> [!important]  
> У RUP и UP больше общего, чем отличий  

И RUP, и UP моделируют, _кто_, _когда_ и _что_ в процессе разработки ПО, но делают это немного по-разному

  

Однако сам UML способен предоставить (и предоставляет) поддержку визуального моделирования другим методам. Конкретным примером сложившегося метода, использующего UML в качестве визуального синтаксиса, является метод OPEN (Object-oriented Process, Environment and Notation - объектно-ориентированный процесс, среда и нотация) (www.open.org.au)

Примером реализации UML, имеющий язык действий, совместимый с семантикой действий, является xUML, произведенный компанией Kennedy Carter (www.kc.com). Тут еще упомянается про iUML - язык спецификации действий (Action Specification Language, ASL)

Метамодель UML - это модель языка UML, выраженная в подмножестве UML

> Гради Буч: “если у вас есть хорошая идея, она моя”

UML объединяет лучшие идеи “доисторических” методов, отказываясь от их наиболее специфических деталей

MDA (model driven architecture) - архитектура, управляемая моделью

Eclipse Modeling Framework (www.eclipse.org/emf) и AndroMDA (www.andromda.org) - иницативы, поддерживающие MDA

> Сущности - это существительные UML-модели

> Модель - это хранилище всех сущностей и отношений, созданных для описания требуемого поведения проектируемой программной системы

Общая ошибка новичков в UML-моделях состоит в том, что они удаляют сущности с диаграмм, не удаляя их из модели

Как правило, работа идет одновременно над несколькими диаграммами, каждая из которых уточняется по мере выявления более подробной информации о разрабатываемой программной системе

> Спецификация - это текстовые описания семантики элемента

> [!important]  
> Спецификации формируют семантический задний план (semantic backplane), который объединяет модель и наполняет её смыслом  

Однако развитие всегда происходит по нарпавлению к согласованным моделям, достаточно полным для создания программных систем

Модель можно считать полезной или полной, только если семантика модели присутствует в **семантическом заднем плане**

> [!important]  
> Обычно нет необходимости показывать на диаграмме все до мельчайших подробностей. Важнее то, чтобы диаграмма была понятной, иллюстрировала именно те аспекты, которые требуются, и была легкой для восприятия  

В UML существуют два принятых деления: классификатор/экземпляр и интерфейс/реализация

В UML экземпляр обычно обозначается той же пиктограммой, что и соответствующий классификатор, но для экземпляров имя на пиктограмме подчернкуто.

|**Классификатор**|**Семантика**|
|---|---|
|Актер|Роль, выполняемая внешним пользователем системы, которому система предоставляет некоторые услуги|
|Класс|Описание набора объектов, обладающих одинаковыми свойствами|
|Компонент|Модульная или замещаемая часть системы, инкапсулирующая свое содержимое|
|Интерфейс|Набор операций, используемых для определения сервисов, предлагаемых классом или компонентом|
|Узел|Физический элемент, существующий во время выполнения и предоставляющий собой вычислительный ресурс, например, ПК|
|Сигнал|Асинхронное сообщение, передаваемое между объектами|
|Прецедент|Описание последодовательности действий, осуществляемых системой для предоставления пользователю результата|

Французские кавычки -« »

Книга “UML Reference Manual” определяет архитектуру системы как “Организационную структуру системы, включая её разбиение на части, их связанность, взаимодействия, механизмы и направляющие принципы, передающие конструкцию системы”

IEEE определяет архитектуру как “высокоуровневое представление системы в её окружении”

Архитектура описывает стратегические аспекты разбиения системы на компоненты, а также взаимодействия и развертывания этих компонент на аппаратных средствах

> Артефакты - это сущности, являющиеся входными данными и результатами проекта

  

## Глава 2

  

Следует заметить, что UML был стандартизован OMG, UP - нет. Поэтому до сих пор не существует стандартного SEP (software engineering process) для UML

Метод “Разделяй и властвуй” является предтечей того, что сегодня известно как компонентно-ориентированная разработка

  

> [!important]  
> В UML большие блоки называются подсистемами, и каждая подсистема реализуется меньшими блоками, называемыми компонентами.  

SDL (Specification and Description Language) - язык спецификации и описания от международной организации по стандартизации CCITT. Один из первых языков визуального моделирования, основанный на концепции объектов

Если не атаковать риски, они будут атаковать вас

История показывает, что людям, вообще говоря, решать маленькие проблемы легче, чем большие

Каждая итерация включает все элементы обычного проекта по разработке ПО

Инкремент - это просто разница между двумя последовательными базовыми версиями

Жизненный цикл проекта разделен на 4 фазы: Начало, УТочнение, Построение и Внедрение

![[Untitled 24.png|Untitled 24.png]]

Цель фазы Начало - сдвинуть проект с мертвой точки

В задачи фазы Уточнение входит создание неполной, но рабочей версии системы - исполняемой базовой версии архитектуры

Построение - построение ПО, базовая функциональность

Внедрение - развертывание ПО в пользовательской среде: Выпуск продукта

  

## Глава 3

Рабочий поток определения требований. Его цель - достижение соглашения о функциях системы, написанного на языке пользователей системы

> [!important]  
> Требования указывают, что должно быть построено, но не говорят, как это сделать  

Хотя теоритечески, конечно же, очень привлекательно отделить “что” от “как”, но на практике набор требований скорее будет смесью “что” и “как”.

Для любого документа с требованиями, в какой бы форме он не был представлен, ключевыми вопросами являются “Насколько он мне полезен?” и “Помогает ли он мне понять, что должна делать система?”. К сожалению, полезность таких произвольым образом оформленных документов ограничена.

Для записи требований используется утверждение shall (должна)

Функциональоное требования - это то, что система должна сделать

Нефункциональное требования - это ограничение, накладываемое на систему

Преимущство набора критериев MoSCoW в его простоте. Однако в нем смешиваются два разных свойства требованиий: важность и очередность

RUP определяет более полный набор атрибутов требований, в котором разделены важность (Benefit) и очередность (TargetRelease).

> [!important]  
> Количество атрибутов требований должно быть минимальным. От этого проект только выиграет.  

Метод функциональоных точек - ifpug.org

Stability (стабильность) - оценка вероятности того, что по каким-то причинам требование будет изменено.

Vision - обозначить наиболее важные цели системы с т.з. заинтересованных сторон

Выяснение требований - карта местности еще не территория

> [!important]  
> Три фильтра - пропуск, искажение и обобщение - формируют естественный язык  

- Пропуск - информация отфильтровывается
- Искажение - информация изменяется взаимосвязанными механизмами вымысла и представления
- Обобщнеие - информация обобщается в правила, убеждения и понятия об истинности и ложности

Кванторы общности: все, каждый, всегда, никогда, никто, нисколько, …

При встрече с квантарома общности всегда можно найти пропуск, искажение или обобщение.

> [!important]  
> Обычно при проведении анализа следует ставить под сомнение кванторы общности. Чуть не написали “всегда следует ставить под соменение кванторы общности”, но тогда бы мы опровергали самих себя!  

Не заблуждайтесь по поводу решения - вам может казаться, что вы очень хорошо понимаете, чего хотят заинтересованные стороны. Но во время интервью это предположение не должно учитываться. Это единственная возможность выяснить, что им нужно на самом деле.

Задавайте контекстно-свободные вопросы

> [!important]  
> Не занимайтесь телепатией  

Телепатия - это заблуждение по поводу того, что вам известны чьи-то чувства, желания и мысли, базирующееся на том, что вы чувствовали бы, желали бы или думали бы в подобной ситуации. Это важнейшая человеческая способность, потому что она является основой сочувствия. Однако это может внести субъективность в процесс выяснения требований, и все закончится тем, что вы хотите, а не в чем нуждаются заинтересованные лица.

  

## Глава 4

Моделирование прецедентов - еще ода форма выработки требований

Прецедент - способ записи требований

> [!important]  
> Прецедент описывает поведение, демонстрируемое системой с целью получения значимого результата для одного или более актеров.  

Прецедент - это что-то, что должна делать система по желанию актера. Это “Вариант использования” системы конкретным актером:

- прецеденты всегда запускаются актером;
- прецеденты всегда описываются с т.з. актеров.

umlandtheunifiedprocess.com

Функциональные требования предложат прецеденты и актеров. Нефункциональные требования - то, о чем надо помнить при создании модели прецедентов.

> [!important]  
> В UML 2 границу системы называют контекстом системы (subject)  

Контекст системы определяется тем, кто и или что используют систему (т.е. актерами) и тем, какие конкретные преимущества система предлагает этим актерам (т.е. прецедентами)

> [!important]  
> Актеры - это роли, исполняемые сущностями, непосредственно вазимодействиющии с системой  

Роль подобна шляпе, которую надевают в определенной ситуации

Основная ошибка новичков в моделировании прецедентов - смешивание роли, выполняемой некоторой сущностью в контексте системы, с самой сущностью.

Всегда спрашивайте, какую роль играет эта сущность по отношению к системе

Пиктограмма actor или анимационный человечек

Системы обычно имеют некоторое внутренне представление одного или более актеров.

Актер Customer является внешним по отношению к системе, но система может обслуживать класс CustomerDetails, который является внутренним представлением субъектов, играющих роль актера Customer.

Чтобы выявить актеров:

- Кто или что используют систему?
- Какие роли они играют во взаимодействии?
- Кто устанавливает систему?
- Кто или что запускает и выключает систему?
- Кто обслуживает систему?
- Какие системы взаимодействуют с данной системой?
- Кто или что получает и представляет информацию системе?
- Происходит ли что-нибудь в точно установленное время? (Актер подн названием Time)

Чтобы идентифицировать прецеденты:

- Какие функциональные возможности понадобятся конкретному актеру от системы?
- Система сохраняет и извлекает информацию? Если да, какой из актеров инициирует это поведение?
- Что происходит, когда система изменяет состояние? (например, при запуске или выключении системы)? Кто-нибудь из актеров получает при этом уведомление?
- Какие-либо внешние события оказывают влияние на систему? Как система узнает о них?
- Система взаимодействует с какой-либо внешней системой?
- Система генерирует какие-либо отчеты?

Разрешение на применение синонимов может привести к возникновению двух более или менее одинаковых классов с разными именами

Для омонимов - выбрать одно значение для определенного термина, для других ввести новые термины

Чем глоссарий понятнее и проще в использовании, тем сильнее его положительное влияние на проект.

Записывайте прецеденты на структурированном естественном языке

Имя прецедента - глагол или глагольная группа. Короткое и описательное одновременно

Главные **актеры** инициируют прецедент. Второстепенные **актеры** не инициируют прецедент.

Предусловия ограничивают состояние системы, необходимое для запуска прецедента. Постусловия ограничивают состояние системы после выполнения прецедента.

Основной поток описывает идеальный ход развития событий в прецеденте.

Можно прецедент представиь как дельту реки. Основное русло и меньшие рукава - альтернативные потоки.

Удачным способом начала потока можно считать следующую форму записи:

> [!important]  
> Прецедент начинается, когда <актер> <действие>  

Каждый этап: <номер> <кто-либо> <совершает некоторое действие>

Повествовательная форма не рекомендуется, потому что ялвяется слишком неопределенной

> Прецедент должен быть точным описание части выполняемых функций системы!

  

Если в процессе анализа встречаются неопределенности, пропуски или обобщения, полезно ставить следующие вопросы.

- Кто именно..?
- Что именно..?
- Когда именно..?
- Где именно..?

Небольшое простое ветвление потока допустимо

Альтернативные потоки часто не возвращаются в основной поток

У альтернативного потока не должно быть альтернативных потоков, иначе описание прецедента становится слишком запутанным

Документируйте только самые важные альтернативные потоки

Группируйте похожие альтернативные потоки. Документируйте один из них. Остальные добавляйте в примечание, где объясняйте отличия.

Не увязать в альтернативных потоках

> [!important]  
> Прецеденты выявляется с целью понять требуемое поведение системы, а не с целью создания полной модели прецедентов  

Матрица отображаемости требований - полезный инструмент для проверки согласованности

Прецеденты хорошо применять для определения функциональности системы. Они плохо подходят для выявления ограничений системы.

  

## Глава 5

Дочерний прецедент автоматически наследует все возможности своего родителя. Однако не все возможности прецедента могут быть переопределены.

Extend - возможность ввести новое поведение в существующий прецедент

Базовый прецедент ничего не знает о расширяющих прецедентах. Он полон сам по себе.

Отношение Extend предоставляет хороший способ обработки исключительных ситуаций или ситуаций, когда нужен гибкий карказ, поскольку невозможно предсказать (или просто не известны) все возможные расширения

Extend рекомендуется не использовать. Если все же используется, то все ЗЛ должны понимать и соглашаться с его семантикой.

Include - базовый прецедент не полон без включения других прецедентов

> Лучшие модели прецедентов - это простые модели

- Если сомневаешься, не включай

Бумажная жадность - стремление к непомерному увеличению объема документации

В реальности большинство прецедентов короче половины страницы

> [!important]  
> Прецеденты создаются для того, чтобы понять, чего актеры ждут от системы, а не как она должна это осуществлять  

Смешение “что” и “как” является повсеместной проблемой.

  

## Глава 6

Создаваемые модели должны рассказывать историю. Каждая диаграмма должна раскрывать некоторые важные части поведения системы. Иначе зачем они нужны?

Наследование - самая сильная форма связанности классов

Нет ничего хуже, чем создавать аналитическую модель, которая игнорируетсся пользователями или проектировщиками и разработчиками

  

## Глава 7

Конкретный экземпляр класса называется объектом

Вызов операции объекта всегда приводит к изменению значений одного или более его атрибутов или отношений с другими объектами

Метод - это реализация операции

Операция - это описание части поведения.

Состояние объекта - это набор значений атрибутов в любой момент времени

Фактически любой вызов операции, приводящий к изменению сути объект, обсуславливает переход состояний.

Поведение объекта - это то, что он может сделать для нас, т.е. его операции

Сервисы, предлагаемые объектом, - то, что объект может сделать

Объекты кооперируются для осуществления функций системы

UML - подчеркивание в имени класса означает, что это экземпляр класса

Класс - дескриптор набора объектов, имеющих одинаковые атрибуты, операции, методы, отношения и поведение

Класс - это штамп, а объекты - отпечатки этого штампа на листке бумаги

Класс - это форма для печенья, а объекты - печенье

Классификация - это, наверное, единственный имеющийся у людей способ упорядочить информацию о мире

Классы позволяют описывать набор свойств, которыми должен обладать каждый объект класса, без необходимости описывать каждый из этих объектов

Существует практически неисчислимое количество способов классификации объектов реального мира

> [!important]  
> Каждый объект “лист” принадлежит определенному объекту “дерево”. Деревья не могут обмениваться или совместно использовать листья. И жизненный цикл листа тесно связан и контролируется деревом. Такое отношение в UML называется композицией (composition)  
  
> [!important]  
> ЖЦ внешних устройств обычно не зависит от ЖЦ компьютера. В UML этот тип отношений объектов называется агрегацией (aggregation)  

Конструктор выделяет память для нового объекта, присваивает ему уникальный идентификатор и задает исходные значения атрибутов. Он также настраивает все связи с другими объектами

  

В аналитических моделях обычно необходимо показывать только:

- имя класса
- ключевые атрибуты
- ключевые операции
- стереотипы (если они приносят пользу делу)

Обычно не показывают следующее:

- Помеченные значения
- Параметры операций
- Видимость
- Исходные значения (если только они не значимы для дела)
- Конструктор

  

Во что бы то ни стало необходимо избегать сокращений

Аббревиатуры затрудняют чтение модели (и результирующего кода). Время, сэкономленное при наборе, не сравнимо со временем, необходимым для обслуживания моделей или кода с сокращенными именами

OCL - объектный язык ограничений (object constraint language) - формальный язык для выражения ограничений в UML-моделях

||Простой тип|Семантика|
|---|---|---|
|UML|Integer|Целое число|
||UnlimitedNatural|Целое число ≥ 0  <br>Бесконечность обозначается как *|
||Boolean|Может принимать значения `true` и `false`|
||String|Последовательность символов.  <br>Строковые литералы заключаются в кавычки, например “Джим”|
|OCL|Real|Число с плавающей точкой|

Добавить простой тип можно, создав класс с таким же именем и стереотипом “primitive”. У такого класса обычно нет атрибутов или операций, поскольку он просто выступает в роли структурного нуля для простого типа, добавляя его имя в пространство имен модели.

  

Имя класса записывается в стиле UpperCamelCase

Имена операций записываются в стиле lowerCamelCase

  

На самом деле направления параметров являются вопросом проектирования, поэтому обычно во время анализа о них не заботятся (если только не используется OCL)

  

Операция запроса - не имеет побочных эффектов и не меняет состояния объекта, в котором вызывается

Более или менее универсальный способ наименования операций запроса - ставить приставку `get` перед именем того, что вы запрашиваете. Например, `getBalance()`

Иногда нужно определить атрибуты, которые имеют единственное, общее на всех оббъекто класса значение. И нужны операции (как операции создания объектов), не относящиеся ни к одному конкретному экземпляру класса. **Говорят, что такие атрибуты и операции имеют область действия - класс.**

Операции, область действия которых - класс, могут организовывать доступ только к атрибутам и операциям, имеющим область действия - класс

> [!important]  
> Операция - это спецификация функций объекта, создаваемые во время анализа  
  
> [!important]  
> Метод - это реализации функции объекта, создаваемая во время реализации  

  

## Глава 8

Реализации прецедентов - это кооперации объектов, показывающие, как системы взаимодействующих объектов могут реализовать поведение системы, описанное в прецеденте

Классы анализа моделируют важные объекты предметной области

> [!important]  
> Задача ОО аналитика - попытаться прояснить беспорядочные или несоответствующие прикладные понятия и превратить их в то, что может стать основой для класса анализа.  

Класс анализа должен четко и однозначно проекцироваться в реальное прикладное понятие

> Классы анализа будут в конце концов переработаны в один или более проектных класса

Требования важны для всех типов систем, а для некоторых встроенных систем, таких как устройства управления рентгеновскими аппаратами, они могут стать вопросом жизни и смерти

Классы анализа должны представлять “высокоуровневый” набор атрибутов. Они указывают атрибуты, которые, возможно, будут присутствовать в проектных классах

Однако одна операция уровня анализа очень часто разбивается на несколько операций уровня проекта

> [!important]  
> Основное назначения класса анализа состоит в том, что в нем делается попытка уловить суть абстракции, а детали реализации оставляют на этап проектирования  

  

- cohesion - внутрення связанность
- coupling - связанность с другими классами

Обязанности описывают связанный набор операций. Это контракт или обязательство класса по отношению к его клиентам. По существу, обязанность - это сервис, который класс предлагает другим классам

В каждом классе должно быть три-пять обязанностей

Функтоид - это обычная процедурная функция, выдаваемая за класс

  

> [!important]  
> Как указывает Мейер (Meyer) в книге “Object Oriented Software Construction”, нет простого алгоритма правильного выявления классов анализа. Наличие подобного алгоритма было бы равнозначно существованию универсального способа разработки ОО программного обеспечения, что так же невероятно, как появление универсального способа доказательства математических теорем.  

  

CRC-анализ - class-responsibilities-collaborators - класс-обязанности-участники

Этот технический прием использует самый мощный в мире инструмент анализа - клеящуюся записку (стикер)!

Согласно RUP считается полезным искать классы, которые можно обозначить стереотипами “boundary” (граница), ”control”(управление), ”entity” (сущность)

(_привет диаграммам пригодности из_ [[Применение объектного моделирования с использованием UML]])

> [!important]  
> Если граничный класс обслуживат актеров разных типов - это свидетельствует о плохом проектировании  

  

  

  

  

**== Добавить еще цитат ==**

  

  

  

Способы отображения потоковой передачи

  

![[Untitled 9.jpeg|Untitled 9.jpeg]]

Узел расширения обработка набора сущностей

- Область расширения исполняется по одному разу для каждого входного элемента

![[Untitled 1 2.jpeg|Untitled 1 2.jpeg]]

  

![[capture-2023-08-06-10-54-19.jpg]]

> [!important]  
> Компонент представляет модульную часть системы, которая инкапсулирует ее содержимое, и реализация компонента замещаема в рамках его окружения  

Интерфейсы позволяют гибко объединять компоненты.

![[capture-2023-08-29-09-37-45.jpg]]

Для разъединения компонентов в качестве посредников в зависимости всегда используются интерфейсы. Если компоненту требуется интерфейс, представить это можно в виде зависимости между компонентом и интерфейсом либо использовать разъем сборки, как показано на рис. 19.17.

![[capture-2023-08-29-09-52-31.jpg]]

> [!important]  
> Подсистема – это компонент, действующий как единица декомпозиции большой системы  

  

Подсистема – это логическая конструкция, используемая для декомпозиции большой системы в управляемые части. Экземпляры самих подсистем не могут создаваться во время выполнения, но могут создаваться экземпляры их содержимого.

![[capture-2023-08-29-22-04-49.jpg]]

Интерфейсы объединяют подсистемы, создавая архитектуру системы.

Шаблон Фасад скрывает сложную реализацию за простым интерфейсом.

  

подсистема определенного уровня по возможности должна требовать интерфейсы от нижележащего уровня и предоставлять интерфейсы более высокому уровню.

  

> Проектирование контракта – более гибкий подход, чем проектирование реализации.

  

Связанность (coupling) на самом деле является злейшим врагом разработчика объектов, поскольку высоковзаимосвязанные системы тяжело понимать, обслуживать и развивать.

  

> Гибкость может стать причиной сложности, поэтому будьте осторожны.

  

В некотором роде это один из секретов хорошего ОО анализа и проектирования: выявление стабильных и нестабильных частей системы и соответствующее их моделирование.

  

**правильное моделирование системы важнее, чем ее гибкость.** Всегда основное внимание необходимо уделять прежде всего правильному моделированию ключевой бизнес-семантики и только потом думать о гибкости. Запомните правило KISS – keep interfaces sweet and simple (интерфейсы должны быть удобными и простыми)!

  

Интерфейс определяет именованный набор открытых свойств

  

если интерфейс отображается без операций, используется нотация в стиле **«леденец на палочках».**

  

> [!important]  
> Разъем сборки – объединяет предоставляемый и требуемый интерфейсы.  

  

Сравнение реализации интерфейса с наследованием:

- реализация интерфейса – «реализует определенный контракт»;
- наследование – «является»;
- и наследование, и реализация интерфейса формируют полиморфизм;
- интерфейсы используются для описания общих протоколов

  

> [!important]  
> Порт – группирует семантически связный набор предоставляемых и требуемых интерфейсов:- может иметь имя, тип и видимость.  

  

**Компонентно-ориентированная разработка (CBD)** занимается построением программного обеспечения из подключаемых частей:

- чтобы сделать компоненты «подключаемыми», применяются интерфейсы;
- проектирование интерфейса позволяет использовать много разных реализаций множеством различных компонентов.

Выявление интерфейсов:

- ставим под сомнение ассоциации;
- ставим под сомнение отправки сообщений;
- выделяем группы многократно используемых операций;
- выделяем группы повторяющихся операций;
- выделяем группы повторяющихся атрибутов;
- ищем классы, играющие в системе одну и ту же роль;
- ищем возможности будущего расширения;
- ищем зависимости между компонентами.

  

  

Проектная реализация прецедента – это взаимодействие проектных объектов и проектных классов, реализующих прецедент.

Синхронизация всех артефактов является составной частью проекти?рования.

При анализе основное внимание в реализации прецедентов было сосре?доточено на том, что должна делать система. В проектировании нас интересует, как система собирается это делать.

  

sequence diagram

На этапе анализа

![[capture-2023-09-01-20-32-29.jpg]]

На этапе проектирования

![[capture-2023-09-01-20-33-42.jpg]]

оператор **par** на диаграммах последовательностей

Раздел **critical** представляет атомарное поведение, которое не может быть прервано. Это важное уточнение, поскольку вызов пожарного датчика является критически важным для безопасности и не может быть прерван.

![[capture-2023-09-03-15-29-56.jpg]]

На коммуникационных диаграм?  
мах можно показать вложенные циклы, но нет способа сделать это просто и ясно! В сложных случаях рекомендуется использовать диаграммы последовательностей. Их синтаксис более четкий и гибкий.  

> Мы говорим «временное окно», а не «время», потому что абсолютное время для нас как разработчиков неприемлемо. Когда в модели задается время, на самом деле задается время плюс?минус некоторая погрешность, определяемая внешними факторами, такими как точность системных часов. Обычно это не является проблемой, за исключением систем с очень точными временными ограничениями.

Временные диаграммы

![[capture-2023-09-03-15-38-57.jpg]]

![[capture-2023-09-03-16-45-14.jpg]]

![[capture-2023-09-03-16-54-43.jpg]]

Глава 22

![[capture-2023-09-10-20-06-02.jpg]]

  

Основная стратегия состоит в том, что один подавтомат задает значения атрибутов, а другие подавтоматы используют их в сторожевых условиях своих переходов.

![[capture-2023-09-14-21-25-56.jpg]]

заказ не может быть доставлен, пока не будет укомплектован и оплачен.

Мы добились асинхронного взаимодействия двух подавтоматов с помощью атрибута, выступающего в роли флага, значение которого задается одним подавтоматом, а запрашивается другим. Это простой и широко используемый механизм.

Предыстория позволяет суперсостоянию при возвращении после прерывания «начинать с того, на чем остановился».

Псевдосостояние неглубокой предыстории запоминает, в каком подсостоянии вы находились при выходе из суперсостояния.

![[capture-2023-09-14-21-33-49.jpg]]

Неглубокая предыстория обеспечивает запоминание подсостояния, находящегося на том же уровне, что и сам индикатор состояния предыстории.

Глубокая предыстория запоминает последнее подсостояние того же или более низкого уровня, чем псевдосостояние глубокой предыстории.

![[capture-2023-09-14-21-37-33.jpg]]

![[capture-2023-10-08-08-12-01.jpg]]

Ocl

![[capture-2023-10-08-14-00-22.jpg]]

Рассматривая возможность использования OCL на диаграммах деятельности, всегда необходимо учитывать назначение диаграммы и ее целевую аудиторию.

Пример модели прецедентов

![[capture-2023-10-08-14-04-05.jpg]]

SUPR - язык описания use case. Похож на разметку. Но как-то больше нужен для представления

OCL - язык описания ограничений. Очень награможденный, имхо. Проще писать текстовые примечания