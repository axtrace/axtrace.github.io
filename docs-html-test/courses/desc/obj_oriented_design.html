<!DOCTYPE html>
<html lang="ru" dir="ltr">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <base href="../../" />
        <title>Название и ссылка | AXTRACE Knowledge Base</title>
        
        
        <meta name="generator" content="Diplodoc Platform v5.19.6">
        
        <style type="text/css">html, body {min-height:100vh; height:100vh;}</style>
        
        
        <link type="text/css" rel="stylesheet" href="_bundle/vendor-f45110f7db3ac665.css"/>
        <link type="text/css" rel="stylesheet" href="_bundle/app-7247a873cd415a5e.css"/>
    </head>
    <body class="g-root g-root_theme_light">
        <div id="root"></div>
        <script type="application/json" id="diplodoc-state">
            {"data":{"leading":false,"html":"&lt;p&gt;&lt;a href=\"https://www.coursera.org/learn/object-oriented-design\" target=\"_blank\" rel=\"noreferrer noopener\"&gt;Объектно-ориентированное проектирование (Object Oriented Design)&lt;/a&gt;&lt;/p&gt;\n&lt;h1&gt;Общее мнение&lt;/h1&gt;\n&lt;p&gt;Курс очевидно начального уровня. Вводит в объекто-ориентированное проектирование (или дизайн, по ихнему). Инкапсуляция, наследование, полиморфизм - вот это вот все.&lt;br /&gt;\nМне лично он был полезен, как вспоминание основ и закрепление терминов. Не путать абстракцию с агрегацией, и всё такое.&lt;br /&gt;\nПригодится перед следующим курсом этой специализации, уже по нормальному проектированию.&lt;br /&gt;\nНу и один-два хинта, которые может быть где-то пригодятся. И сертификат прибить к линкедину, который формально покажет девочкам из hr, что я \"саморазвиваюсь\".&lt;/p&gt;\n&lt;h1&gt;Чуть более детальный обзор&lt;/h1&gt;\n&lt;p&gt;Файл с заметками к курсу доступен тут: &lt;a href=\"courses/desc/files/OOD_Course_notes.pdf\"&gt;Course notes.pdf&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Де-юро курс состоял из 4 модулей. Но де-факто модулей было 3. Последний - проверочный.&lt;br /&gt;\nКаждый модуль на неделю. Но обычно модуль занимал у меня 2-3-4 недели.&lt;/p&gt;\n&lt;p&gt;MODULE 1: OBJECT-ORIENTED ANALYSIS AND DESIGN&lt;br /&gt;\nMODULE 2: OBJECT-ORIENTED MODELLING&lt;br /&gt;\nMODULE 3: DESIGN PRINCIPLES&lt;br /&gt;\nMODULE 4: Capstone Challenge&lt;/p&gt;\n&lt;p&gt;Пройдемся тут по первым трём модулям в их порядке.&lt;/p&gt;\n&lt;h3 id=\"module-1-object-oriented-analysis-and-design\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#module-1-object-oriented-analysis-and-design\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;MODULE 1: OBJECT-ORIENTED ANALYSIS AND DESIGN&lt;/span&gt;&lt;/a&gt;MODULE 1: OBJECT-ORIENTED ANALYSIS AND DESIGN&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;Объекты мы встречаем в природе. Они имеют свойства и поведения с ответственностями&lt;/li&gt;\n&lt;li&gt;ООП позволяет коду оставаться структурированным, гибким и сохраняет возможность переиспользования\n&lt;ul&gt;\n&lt;li&gt;Структурированность - всегда понятно, где искать детали объектов и функции&lt;/li&gt;\n&lt;li&gt;Гибкость. Модульность. Изменения вносятся в объект без прямого влияния на другой код.&lt;/li&gt;\n&lt;li&gt;Переиспользование. Сокращает и упрощает код&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Примечание: это всё известно с ранних 90х. Хнык&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Процесс разработки итеративный: выявленные проблемы -&amp;gt; набор требований -&amp;gt; концетуальные дизайн макеты -&amp;gt; технический дизайн диаграммы -&amp;gt; внедрение -&amp;gt; тест&lt;/p&gt;\n&lt;p&gt;Дизайн (проектирование) – это всегда торговля между различными атрибутами качества: производительность, поддерживаеомсть, надежность, безопасность и т.п.&lt;/p&gt;\n&lt;p&gt;Смотрят, как атрибуты качества будут достигаться в различных ситуациях при выбранном дизайне.&lt;br /&gt;\nНе забываем про контекст. И про масштабирование. Например, для малых объемов что-то работает, а для больших – уже не будет.&lt;/p&gt;\n&lt;p&gt;Приводят технику CRC Cards (Class, Responsibility, Collaborator) - техника (понятно, что одна из), которая позволяеот отразить на верхнем уровне компоненты, ответственности и связи, сформированные на этапе концептуального дизайна.&lt;br /&gt;\nПростой доступный способ с возможностью редактировать, как говорят нам авторы курса.&lt;br /&gt;\nГлавное достоинство – физически «почувствовать» дизайн. Помогает выявлять недостатки.&lt;br /&gt;\nМожно играться с порядком карточек и щупать дизайн.&lt;br /&gt;\nА также понимать связи между элементами.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Примечание: мне так и осталось непонятным, зачем они вводили эти  CRC Cards. Все преимущества этой \"техники\" покрываются диаграммой классой в UML или ER-диаграммой&lt;br /&gt;\nВидимо, как переходный этап от нуля к этим диаграммам.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\"module-2-object-oriented-modelling\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#module-2-object-oriented-modelling\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;MODULE 2: OBJECT-ORIENTED MODELLING&lt;/span&gt;&lt;/a&gt;MODULE 2: OBJECT-ORIENTED MODELLING&lt;/h3&gt;\n&lt;p&gt;4 кита, на которых держится OOM (the four major design principles used in object-oriented modelling):&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;Abstraction&lt;/strong&gt; – представление концета в виде упрощенного описание, игнорируя неважные детали и подчеркивая необходимые основы с учетом контектсов.&lt;br /&gt;\nСледует придерживаться &lt;strong&gt;принципа наименьшего удивления&lt;/strong&gt;: правило предлагает что атрибут и поведение должны быть реализованы без сюпризов и не иметь смыслов, выходящих за рамки.&lt;br /&gt;\nПо сути, абстракция – это выявление классов, их ответственностей, атрибутов и методов.&lt;br /&gt;\nПри этом, это все далется наиболее релевантным образом с учетом контекста.&lt;br /&gt;\nПринципы абстракции помогают упростить проект классов, так что классы более сфокусированны, лаконичны и понятны для читателя.&lt;br /&gt;\nВажно понимать, что при изменении цели системы или решаемой проблемы нужно пересматривать абстракции на предмет релевантности новому контексту.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;Encapsulation&lt;/strong&gt; – упаковка в «капсулы». К некоторым есть доступн извне, к другим – нет.&lt;br /&gt;\nТри идеи:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Связь значений атрибутов и функций, работающих с ними, в виде объектов, содержащих их внутри&lt;/li&gt;\n&lt;li&gt;Интерфейсы для данных и функций&lt;/li&gt;\n&lt;li&gt;Ограничение доступа к данным и функциям только изнутри объекта&lt;br /&gt;\nИнкапсуляция позволяет определить релевантные к контексту поведения и свойства объектов и связывать их в одних и тех же классах.&lt;br /&gt;\nМожно создавать отдельные экземпляры объектов из классов с собственными значениями атрибутов и поведением.&lt;br /&gt;\nЭто значительно упрощает разработку.&lt;br /&gt;\nТакже тут целостность и защита данных.&lt;br /&gt;\nИ также повышает переиспользуемость из-за мышления как о черном ящике.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;Decomposition&lt;/strong&gt; – разбивка целого на части, которые вместе и образуют целое.&lt;br /&gt;\nПомогает за счет облегчение понимания отдельных частей.&lt;br /&gt;\nОсновное правило – смотреть на общие ответственности целого и оценивать, как можно разбить на части так, чтобы каждая часть имела выделенную ответственность.&lt;br /&gt;\nЧасти также можно делить на части.&lt;br /&gt;\nПример: Дом – Кухня – Холодильник&lt;br /&gt;\nТакже необходимо судить о жизненном цикле.&lt;br /&gt;\nЖизненный цикл отдельной части может прекращаться вместе с жизнью целого, а может и не прекращаться.&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;strong&gt;Generalization&lt;/strong&gt; – помогает бороться с избыточностью при решении задач.&lt;br /&gt;\nНапример, методы – это пример обощения.&lt;br /&gt;\nМетоды позволяют применять поведение к различным входным данным.&lt;br /&gt;\nНет необходимости иметь одинаковые куски кода по всей программе.&lt;br /&gt;\nООП достигает обобщения классов за счет наследования.&lt;br /&gt;\nВынос общего поведения или характеристик в отдельные классы.&lt;br /&gt;\nРодительские классы (суперклассы) и классы-дети (сабклассы).&lt;br /&gt;\nБез родительских классов код системы не будет гибкой, управляемой и переиспользуемой.&lt;br /&gt;\nРодительские классы экономят время и предотвращают ошибки.&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Эти принципы помогают в решение проблем и помогают разрабатывать гибкое, переиспользуемое и управлеяемой ПО.&lt;/p&gt;\n&lt;p&gt;Дизайн (в смысле проектирование) предполагает многократное итеративное перемещение из пространства проблемы в пространство решений и обратно.&lt;/p&gt;\n&lt;p&gt;Давно разработали ООП (объекто-ориентированно проектирование). Это эффективный способ проектирования, но могут быть задачи, для которых лучше подходят другие парадигмы.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Концептуальный дизайн использует ООП для выявления основных объектов и разбивки задачи на управляемые части. Тут пойдут и CRC-cards, как говорят авторы курса.&lt;/li&gt;\n&lt;li&gt;Технический дизайн использует ООП для дальнейшей детализации объектов, их атрибутов и поведения. Помогает разработчикам.&lt;br /&gt;\nТехнический дизайн более удовлетворяет диаграмма классов UML. Тут больше деталей и легче конвертировать в классы в коде.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Дальше посмотрим, как 4 основных принципа (те 4 кита) ложаться на UML.&lt;/p&gt;\n&lt;h4 id=\"abstraction\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#abstraction\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;Abstraction&lt;/span&gt;&lt;/a&gt;Abstraction&lt;/h4&gt;\n&lt;p&gt;Здесь нечего сказать. Сам факт выделения объектов и отрисовки их на диаграммах и есть абстракция&lt;/p&gt;\n&lt;h4 id=\"encapsulation\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#encapsulation\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;Encapsulation&lt;/span&gt;&lt;/a&gt;Encapsulation&lt;/h4&gt;\n&lt;p&gt;UML Class diagram – в каждой сущности задаем три блока:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Class name,&lt;/li&gt;\n&lt;li&gt;properties (:),&lt;/li&gt;\n&lt;li&gt;operations ((  ) : )&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Пример класса:&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\"text-align:left\"&gt;Student&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\"text-align:left\"&gt;-gpa: float&lt;br /&gt;-degreeProgram: String&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\"text-align:left\"&gt;+getGPA(): float&lt;br /&gt;+setGPA( float )&lt;br /&gt;+getDegreeProgram(): String&lt;br /&gt;+setDegreeProgram( String )&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;h4 id=\"decomposition\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#decomposition\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;Decomposition&lt;/span&gt;&lt;/a&gt;Decomposition&lt;/h4&gt;\n&lt;p&gt;Три типа отношений, определяющих взаимодействие целого и частей:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;Association&lt;/strong&gt; – два объекта независимы друг от друга и просто взаимодействуют.&lt;br /&gt;\nЕсли один объект «умирает», другой продолжает существовать.&lt;br /&gt;\nЛюбое число объектов во взаимодействии.&lt;br /&gt;\nОдин объект не принадлежит другому. Пример: человек – отель.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;img src=\"_images/courses/desc/img/Association.png\" alt=\"\" /&gt;&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;Aggregation&lt;/strong&gt; - is a “has-a” relationship.&lt;br /&gt;\nЦелое владеет частями.&lt;br /&gt;\nЧасти могут разделяться между целыми в этом отношении.&lt;br /&gt;\nСлабое отношение.&lt;br /&gt;\nХотя части могут и принадлежать целому, они могут и существовать независимо от него.&lt;br /&gt;\nПример: самолет и экипаж.&lt;br /&gt;\nСамолет не сможет предлагать сервис без экипажа.&lt;br /&gt;\nТем не менее, самолет не перестанет существовать без экипажа.&lt;br /&gt;\nАналогично и экипаж.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;img src=\"_images/courses/desc/img/Aggregation.png\" alt=\"\" /&gt;&lt;br /&gt;\nПустой ромб определяет целое в этом отношении двух объектов.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;Composition&lt;/strong&gt; – is a strong “has-a”.&lt;br /&gt;\nЦелое не может существовать без своих частей.&lt;br /&gt;\nИ если целое уничтожается, то уничтожаются и части тоже.&lt;br /&gt;\nОбычно в таком отношении доступ к частям возможен только через целое.&lt;br /&gt;\nПример: дом – комната.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;img src=\"_images/courses/desc/img/Composition.png\" alt=\"\" /&gt;&lt;br /&gt;\nРомб определяет целое.&lt;/p&gt;\n&lt;h4 id=\"generalization\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#generalization\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;Generalization&lt;/span&gt;&lt;/a&gt;Generalization&lt;/h4&gt;\n&lt;p&gt;Выделение общих повторяемых характеристик у нескольких классов. Наследование.&lt;/p&gt;\n&lt;p&gt;&lt;img src=\"_images/courses/desc/img/Generalization.png\" alt=\"\" /&gt;&lt;/p&gt;\n&lt;p&gt;Абстрактый объект не может быть создан.&lt;br /&gt;\nТипы наследования в Java:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Implementation inheritance&lt;/li&gt;\n&lt;li&gt;interface inheritance. Вместо multiple inheritance в C++&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;A Java interface also denotes a type, but an interface only declares method signatures, with no constructors, attributes, or method bodies. polymorphism.&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;img src=\"_images/courses/desc/img/polymorphism.png\" alt=\"\" /&gt;&lt;/p&gt;\n&lt;h3 id=\"module-3-design-principles\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#module-3-design-principles\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;MODULE 3: DESIGN PRINCIPLES&lt;/span&gt;&lt;/a&gt;MODULE 3: DESIGN PRINCIPLES&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;Оценка сложности с учетом связанности и сплоченности (coupling and cohesion)&lt;/li&gt;\n&lt;li&gt;Разделение интересов (the separation of concerns)&lt;/li&gt;\n&lt;li&gt;Сокрытие информации (Information Hiding)&lt;/li&gt;\n&lt;li&gt;Концептуальная целостность&lt;/li&gt;\n&lt;li&gt;Принципы обобщения&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Гайды для убеждения, что ПО гибкое, переиспользуемое, управляемое.&lt;/p&gt;\n&lt;p&gt;Также покрывает моделирование поведения объектов. UML State Diagram и UML sequence diagrams.&lt;/p&gt;\n&lt;p&gt;Модуль – классы и их методы&lt;/p&gt;\n&lt;p&gt;Нужна оценка сложности дизайна.&lt;br /&gt;\nХороший дизайн позволяет любым модулям соединяться без больших проблем.&lt;br /&gt;\nИли другими словами, модули совместимы друг с другом и могут переиспользвоаться&lt;/p&gt;\n&lt;p&gt;В качетсве метрик для оценки дизайна часто используются coupling and cohesion&lt;/p&gt;\n&lt;h5 id=\"coupling\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#coupling\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;Coupling&lt;/span&gt;&lt;/a&gt;Coupling&lt;/h5&gt;\n&lt;p&gt;&lt;strong&gt;Coupling&lt;/strong&gt; (сцепленность)– фокусируется на сложности между разными модулями.&lt;br /&gt;\nОт слабой сцепления (loosely coupled) до сильного сцепления (tightly coupled).&lt;br /&gt;\nЕсли модуль сильно зависит от другого, это сильное сцепление. Это плохой дизайн.&lt;br /&gt;\nА если модуль легко связать с другими с помощью хорошо определенных интерфейсов, это слабая сцепленность с другими. Это хороший дизайн.&lt;br /&gt;\nДля оценки сцепленности в свою очередь используют степень, простоту и гибкость.&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Степень – это количество связей между модулем и другими модулями.&lt;br /&gt;\nИх должно быть мало.&lt;br /&gt;\nНапример, модуль должен связываться с другими с помощью нескольких параметров или узких интерфейсов.&lt;/li&gt;\n&lt;li&gt;Простота – это насколько очевидны связи между модулем и другими.&lt;br /&gt;\nСвязи должны быть достаточно простыми для создания без необходимости понимания реализации других модулей.&lt;/li&gt;\n&lt;li&gt;Гибкость отображает насколько заменяемы другие модули для этого модуля. Другие модули должны легко заменяться на что-то лучшее в будущем.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Признаками сильного сцепления и плохого дизайна:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Модуль связан с другими через огромное количество параметров и интерфейсов&lt;/li&gt;\n&lt;li&gt;Отсылки одного модуля к другому сложно найти&lt;/li&gt;\n&lt;li&gt;Модуль может быть связан только с некоторыми специфичными другими модулями и не может быть заменен&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h5 id=\"cohesion\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#cohesion\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;Cohesion&lt;/span&gt;&lt;/a&gt;Cohesion&lt;/h5&gt;\n&lt;p&gt;&lt;strong&gt;Cohesion&lt;/strong&gt; – сплоченность фокусируется на сложности внутри модуля.&lt;br /&gt;\nИ представляет ясность ответсвенностей модуля. Лежит между high cohesion and low cohesion.&lt;br /&gt;\nМодуль, который выполняет одну задачу и ничего больше, или который имеет явную понятную цель, имеет высокую сплоченность. Это признак хорошего дизайна.&lt;br /&gt;\nС другой стороны, если модуль скрывает более 1 цели, если все сложно понятть методы, или если цели не ясны – это низкая сплоченность. Признак плохого дизайна.&lt;br /&gt;\nЕсли у модуля больше одной ответственности, надо бы его разбивать.&lt;br /&gt;\nВажно держать баланс low coupling and high cohesion в дизайне.&lt;br /&gt;\nНо бывает, что сложность может быть размазана между модулями или в модулях.&lt;br /&gt;\nНапример, модули упрощены для достижения high cohesion, могут зависеть больше от других модулей, что повышает Coupling.&lt;br /&gt;\nС другой стороны, если упрощать связи между модулями для достижения низкой Coupling, может понадобиться дать больше ответственностей в модуль, что снизит cohesion.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Для себя сам изобразил так&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;img src=\"_images/courses/desc/img/cohesion_vs_coupling.png\" alt=\"\" /&gt;&lt;/p&gt;\n&lt;h4 id=\"razedelnie-interesov\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#razedelnie-interesov\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;Разеделние интересов&lt;/span&gt;&lt;/a&gt;Разеделние интересов&lt;/h4&gt;\n&lt;p&gt;Для декомпозии нужен принцип разделения интересов (of separation of concerns).&lt;br /&gt;\nConcern – что-то знамое с т.з. дизайна системы.&lt;br /&gt;\nРазличные консерны лучше держать отдельно. В различных частях ПО.&lt;/p&gt;\n&lt;p&gt;Независимость секций. Можно одну обновить, не зная про другие как они работают.&lt;br /&gt;\nИ изменения можно делать только в одном модуле.&lt;br /&gt;\nОказывается, это ключевая идея объектно-ориентированного моделирования и программирования.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;When addressing concerns separately, more cohesive classes are created and the design principles of abstraction, encapsulation, decomposition, and generalization are enforced:&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h5 id=\"primer\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#primer\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;Пример&lt;/span&gt;&lt;/a&gt;Пример&lt;/h5&gt;\n&lt;p&gt;Вот есть у нас смартфон. Он умеет звонить и фотать. Пусть для него вначале создан класс:&lt;/p&gt;\n\n    &lt;div class=\"yfm-clipboard\"&gt;\n        &lt;pre&gt;&lt;code class=\"hljs java\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;SmartPhone&lt;/span&gt; {\n  &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;byte&lt;/span&gt; camera;\n  &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;byte&lt;/span&gt; phone;\n\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;SmartPhone&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; { … }\n\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;takePhoto&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; { … }\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;savePhoto&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; { … }\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;cameraFlash&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; { … }\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;makePhoneCall&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; { … }\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;encryptOutgoingSound&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; { … }\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;decipherIncomingSound&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; { … }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n        &lt;button class=\"yfm-clipboard-button\"&gt;\n            &lt;svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-icon\" data-animation=\"390\"&gt;\n                &lt;path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"&gt;&lt;/path&gt;\n                &lt;path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\"&gt;\n                    &lt;animate id=\"visibileAnimation-390\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin&gt;&lt;/animate&gt;\n                    &lt;animate id=\"hideAnimation-390\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-390.end+1\" fill=\"freeze\"&gt;&lt;/animate&gt;\n                &lt;/path&gt;\n            &lt;/svg&gt;\n        &lt;/button&gt;\n    &lt;/div&gt;\n&lt;p&gt;Тут у нас low cohesion, потому что внутри класса поведения, которые не связаны друг с другом.&lt;br /&gt;\nПоведение камеры не нуждается в инкапсуляции вместе с поведением телефона для того, чтобы камере делать свою работу.&lt;br /&gt;\nТакже тут нет никакой модульности. Например, невозможно получить доступ отдельно к камере и отдельно к телефону.&lt;br /&gt;\nЕсли одна система билдится, то должна билдиться и другая.&lt;br /&gt;\nКамеру, например, хрен заменишь другой камерой или другим объектом без удаления кода камеры полностью из этого класса.&lt;/p&gt;\n&lt;p&gt;Используя разделение интересов, можем понять, что класс SmartPhone нуждается в двух интересах:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Звонить по телефону&lt;/li&gt;\n&lt;li&gt;Делать фоточки встроенной камерой&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Теперь, когда мы выделили интересы, можно разделить их по своим собственным классам.&lt;br /&gt;\nСобственные классы будут более сплоченными (more cohesive).&lt;br /&gt;\nПолучится инкапсуляция. Независимые интересы в независимых классах.&lt;/p&gt;\n&lt;p&gt;&lt;img src=\"_images/courses/desc/img/uml_smartphone.png\" alt=\"\" /&gt;&lt;/p&gt;\n&lt;p&gt;Атрибуты и поведения телефона и камеры разделены по двум различным интерфейсам.&lt;br /&gt;\nКаждый имплементируется через соответствующий класс:&lt;/p&gt;\n\n    &lt;div class=\"yfm-clipboard\"&gt;\n        &lt;pre&gt;&lt;code class=\"hljs java\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;interface&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;ICamera&lt;/span&gt; {\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;takePhoto&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;;\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;savePhoto&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;;\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;cameraFlash&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;interface&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;IPhone&lt;/span&gt; {\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;makePhoneCall&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;;\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;encryptOutgoingSound&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;;\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;deciphereIncomingSound&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;FirstGenCamera&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;implements&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;ICamera&lt;/span&gt; {\n  &lt;span class=\"hljs-comment\"&gt;/* Abstracted camera attributes */&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;TraditionalPhone&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;implements&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;IPhone&lt;/span&gt; {\n  &lt;span class=\"hljs-comment\"&gt;/* Abstracted phone attributes */&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n        &lt;button class=\"yfm-clipboard-button\"&gt;\n            &lt;svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-icon\" data-animation=\"418\"&gt;\n                &lt;path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"&gt;&lt;/path&gt;\n                &lt;path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\"&gt;\n                    &lt;animate id=\"visibileAnimation-418\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin&gt;&lt;/animate&gt;\n                    &lt;animate id=\"hideAnimation-418\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-418.end+1\" fill=\"freeze\"&gt;&lt;/animate&gt;\n                &lt;/path&gt;\n            &lt;/svg&gt;\n        &lt;/button&gt;\n    &lt;/div&gt;\n&lt;p&gt;Код класса Смартфон теперь будет такой:&lt;/p&gt;\n\n    &lt;div class=\"yfm-clipboard\"&gt;\n        &lt;pre&gt;&lt;code class=\"hljs java\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;SmartPhone&lt;/span&gt; {\n  &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; ICamera myCamera;\n  &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; IPhone myPhone;\n\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;SmartPhone&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;( ICamera aCamera, IPhone aPhone )&lt;/span&gt; {\n    &lt;span class=\"hljs-built_in\"&gt;this&lt;/span&gt;.myCamera = aCamera;\n    &lt;span class=\"hljs-built_in\"&gt;this&lt;/span&gt;.myPhone = aPhone;\n    }\n\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;useCamera&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; {\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;this&lt;/span&gt;.myCamera.takePhoto();\n  }\n\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;usePhone&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; {\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;this&lt;/span&gt;.myPhone.makePhoneCall();\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n        &lt;button class=\"yfm-clipboard-button\"&gt;\n            &lt;svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" class=\"yfm-clipboard-icon\" data-animation=\"422\"&gt;\n                &lt;path fill=\"currentColor\" d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"&gt;&lt;/path&gt;\n                &lt;path stroke=\"currentColor\" fill=\"transparent\" stroke-width=\"1.5\" d=\"M9.5 13l3 3l5 -5\" visibility=\"hidden\"&gt;\n                    &lt;animate id=\"visibileAnimation-422\" attributeName=\"visibility\" from=\"hidden\" to=\"visible\" dur=\"0.2s\" fill=\"freeze\" begin&gt;&lt;/animate&gt;\n                    &lt;animate id=\"hideAnimation-422\" attributeName=\"visibility\" from=\"visible\" to=\"hidden\" dur=\"1s\" begin=\"visibileAnimation-422.end+1\" fill=\"freeze\"&gt;&lt;/animate&gt;\n                &lt;/path&gt;\n            &lt;/svg&gt;\n        &lt;/button&gt;\n    &lt;/div&gt;\n&lt;p&gt;Вот и все. Класс SmartPhone по-прежнему предоставляет функции телефона и камеры.&lt;br /&gt;\nНо телефон и камера разделены по отдельным классам, их функциональность спрятана друг от друга, но они все еще aggregated under the SmartPhone class.&lt;br /&gt;\nКонструктор класса SmartPhone принимает камеру и телефон как параметры.&lt;br /&gt;\nСтало возможно создать новую сущнсоть SmartPhone с помощью передачи на вход сущности классов, которые реализуют интерфейсы ICamera и IPhone.&lt;br /&gt;\nКто создает соответствующие объекты камеры и телефона - это уже отделенная ответственность. И классу SmartPhone не нужно этого знать.&lt;br /&gt;\nНу и наконец, класс SmartPhone имеет методы, которые форвардят ответственность за использование камеры и телефона в соответствующие объекты.&lt;/p&gt;\n&lt;p&gt;Вот он модульный дизайн. В будущем можно легко заменить классы камеры или телефона на что-то еще. И не трогать при этом класс SmartPhone вообще, совсем, т.е. полностью.&lt;/p&gt;\n&lt;p&gt;Класс SmartPhone теперь более сплоченный (more cohesive).&lt;br /&gt;\nПри этом увеличена сцепленность (increased coupling), потому что класс SmartPhone должен знать об интерфейса Камеры и Телефона и косвенно зависит от других классов.&lt;/p&gt;\n&lt;p&gt;В этом примере для разделение интересов было использовано:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Разделение понятний камеры и телефона через обобщение (generalization) и определение двух интерфейсов;&lt;/li&gt;\n&lt;li&gt;Разделение функций камеры и телефона с помощью применения абстракции (abstraction) и инкапсуляции (encapsulation) и определения двух реализующих классов;&lt;/li&gt;\n&lt;li&gt;Применения декомпозиции (decomposition) к Смартфону, таким образом составлюящие части были выделены из целого&lt;/li&gt;\n&lt;/ul&gt;\n&lt;hr /&gt;\n&lt;h4 id=\"sokrytie-informacii\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#sokrytie-informacii\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;Сокрытие информации&lt;/span&gt;&lt;/a&gt;Сокрытие информации&lt;/h4&gt;\n&lt;p&gt;Сокрытие информации - один из концептов доступа к информации.&lt;br /&gt;\nМодули должны иметь доступ только к информации, которая нужна им для выполнения своей работы.&lt;br /&gt;\nСокрытие информации - это ограничение доступа до минимума информации, которая нужна для правильного использования модулей, и сокрытие всего остального.&lt;br /&gt;\nСкрывается не только чувтсвительная информация, но и изменяемые детали, такие как алгоритмы и представления данных. При этом, предположения часто выносятся в API.&lt;br /&gt;\nВещи, которые могут меняться, должны быть скрыты. А вещи, которые не изменятся, должны быть в интерфейсах.&lt;/p&gt;\n&lt;p&gt;В java есть модификаторы доступа:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Public - доступны любым модулем в системе. Другие классы смогут получать и изменять эти атрибуты. Или доступы к методам (но не менять их поведение).&lt;/li&gt;\n&lt;li&gt;Protected - доступны только внутри класса и sub-классам и классам из того же пакета. Пакет в java - это единый namespace&lt;/li&gt;\n&lt;li&gt;Default - доступны подклассам и классам из того же пакета или инкапсуляции. Не нуждается в объявлении. Поэтому часто называют \"no modifier access\"&lt;/li&gt;\n&lt;li&gt;Private - не доступны никому, кроме инкапсулированных внутри класса.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\"konceptualnaya-celostnost-conceptual-integrity\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#konceptualnaya-celostnost-conceptual-integrity\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;Концептуальная целостность (Conceptual Integrity)&lt;/span&gt;&lt;/a&gt;Концептуальная целостность (Conceptual Integrity)&lt;/h4&gt;\n&lt;p&gt;Это концепция единых принципов проектирования и соглашений, нужных для одновременной работы над системой несколькими людьми.&lt;br /&gt;\nИ чтобы система продложала оставаться согласованной, связанной и последовательной, как если бы над ней работал 1 человек.&lt;/p&gt;\n&lt;p&gt;Для достижения этих целей используют:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;общение&lt;/li&gt;\n&lt;li&gt;code reviews&lt;/li&gt;\n&lt;li&gt;соглашения о design principles and programming constructs&lt;/li&gt;\n&lt;li&gt;хорошо определнный дизайн или архитектуру, лежающую в основе системы&lt;/li&gt;\n&lt;li&gt;унифицирование концепций&lt;/li&gt;\n&lt;li&gt;выделенная небольшая группа, имеющая доступ к каждому коммиту в код&lt;/li&gt;\n&lt;/ul&gt;\n&lt;blockquote&gt;\n&lt;p&gt;\"It is better to have a system omit certain anomalous features and improvements, but to reflect one set of design ideas, than to have one that contains many&lt;br /&gt;\ngood but independent and uncoordinated ideas\"&lt;br /&gt;\nFred Brooks, The Mythical Man-Month&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h4 id=\"principy-obosheniya-generalization-principles\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#principy-obosheniya-generalization-principles\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;Принципы обощения (Generalization Principles)&lt;/span&gt;&lt;/a&gt;Принципы обощения (Generalization Principles)&lt;/h4&gt;\n&lt;p&gt;В целом хорошо следовать 4 принципам: abstraction, encapsulation, decomposition, and generalization.&lt;br /&gt;\nНо еще лучше следовать им хорошо.&lt;/p&gt;\n&lt;p&gt;Если принципы проектирования использовать неправильно, они могут создать проблем больше, чем решать.&lt;/p&gt;\n&lt;p&gt;Наследование (Inheritance) отличная техника. Но если её использовать неправильно, можно сделать еще хуже (can lead to poor code).&lt;/p&gt;\n&lt;p&gt;Пара принципов обощения:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Задавать вопрос \"Я использую наследование, чтобы просто делиться атрибутами и поведением, не привнося ничего нового в subclasses?\".&lt;br /&gt;\nЕсли ответ \"да\", то лучше наследование не использовать, потому что нет никаких оснований для существования подклассов. Достаточно суперкласса.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Например: работник - общий тип для менеджеров, продажников, финансистов, но каждый из этих подклассов работников выполняет определенные функции.&lt;br /&gt;\nНаследование может иметь смысл в этом случае.&lt;br /&gt;\nНо если, например, создается несколько различных видов пиццы, и на самом деле нет никакой специализации между разными видами пиццы, то подклассы не требуются.&lt;/p&gt;\n&lt;ol start=\"2\" style=\"--hier-list-start:1\"&gt;\n&lt;li&gt;Другой принцип - определить, не нарушен ли Принцип подстановки Барбары Лисков (Liskov substitution principle, LSP).&lt;br /&gt;\nЭтот принцип гласит, что подкалсс может заменить суперкласс тогда и только тогда, когда подкласс не меняет функциональности суперкласса (во всяком случае так говорится в курсе).&lt;br /&gt;\nЭто означает, что если подкласс заменяет суперкласс, но полностью меняет все поведения суперкласса, то наследование было использовано неправильно или зря.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Например, если класс Кит, у которого есть поведение \"плавать\", заменяется классом Животное, такие функции как \"бегать\" и \"ходить\" будут переписаны.&lt;br /&gt;\nКласс Кит больше не ведет себя так, как ожидалось от его суперкласса, нарушая принцип Барбары Лисков.&lt;/p&gt;\n&lt;p&gt;В тех случаях, когда наследование не применимо, можно использовать декомпозицию.&lt;br /&gt;\nВернемся к примеру со Смартфоном.&lt;/p&gt;\n&lt;p&gt;&lt;img src=\"_images/courses/desc/img/smartphone_decomposion.png\" alt=\"\" /&gt;&lt;/p&gt;\n&lt;p&gt;В этом примере не имеет смысла использовать наследование от традиционного Телефона к Смартфону и затем добавлять методы камеры к подклассу Смартфон.&lt;br /&gt;\nВместо этого, декомпозиция помогает выделить ответственности Камеры в её собственный класс.&lt;br /&gt;\nЭто позволяет классу Смартфону предоставлять ответственности камеры и за телефона через отдельные классы без знания, как они работают.&lt;/p&gt;\n&lt;p&gt;&lt;img src=\"_images/courses/desc/img/uml_smartphone.png\" alt=\"\" /&gt;&lt;/p&gt;\n&lt;p&gt;Хотя наследование - это мощный принцип, важно точно знать, когда использовать эту технику. Иначе существует риск добавления проблем в код.&lt;/p&gt;\n&lt;h3 id=\"specialized-uml-class-diagrams\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#specialized-uml-class-diagrams\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;Specialized UML class diagrams&lt;/span&gt;&lt;/a&gt;Specialized UML class diagrams&lt;/h3&gt;\n&lt;p&gt;Видимо, в конце решили поговорить про диаграммы UML. Как они могут улучшить этап технического дизайна.&lt;br /&gt;\nЯ хз, что о них писать особо. Просто приведу примеры&lt;/p&gt;\n&lt;h4 id=\"uml-sequence-diagrams\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#uml-sequence-diagrams\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;UML Sequence Diagrams&lt;/span&gt;&lt;/a&gt;UML Sequence Diagrams&lt;/h4&gt;\n&lt;p&gt;Помогает улучшить ясность и дизайн программ.&lt;/p&gt;\n&lt;p&gt;&lt;img src=\"_images/courses/desc/img/uml_sequence_diagram.png\" alt=\"\" /&gt;&lt;/p&gt;\n&lt;h4 id=\"uml-state-diagrams\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#uml-state-diagrams\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;UML State Diagrams&lt;/span&gt;&lt;/a&gt;UML State Diagrams&lt;/h4&gt;\n&lt;p&gt;Помогает выделить условия, которые не планировались.&lt;br /&gt;\nТакже помогает прочекать полноту и корректность тестов.&lt;/p&gt;\n&lt;h3 id=\"model-checking\"&gt;&lt;a href=\"courses/desc/obj_oriented_design.html#model-checking\" class=\"yfm-anchor\" aria-hidden=\"true\"&gt;&lt;span class=\"visually-hidden\" data-no-index=\"true\"&gt;Model Checking&lt;/span&gt;&lt;/a&gt;Model Checking&lt;/h3&gt;\n&lt;p&gt;Также важны техники по верификации системы: юнит-тесты, бета-тестинг, симуляции.&lt;br /&gt;\nОдна из техник - Проверка моделей, заключающаяся в систематической проверки системы во всевозможных состояниях её State Model.&lt;br /&gt;\nИ утверждается, что эта техника может выявить ошибки, которые другими техниками не выявляются.&lt;/p&gt;\n&lt;p&gt;Симулируются различные события, которые могут менять состояния или значения переменных в системе.&lt;br /&gt;\nОбычно Model Checking выполняется на этапе тестирования системы с помощью специального ПО.&lt;/p&gt;\n&lt;p&gt;Например, вообразите, что в системе есть правило не доводить до дедлока.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Deadlock is a situation where the system cannot continue because two tasks are waiting for the same resource&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;Model Checker будим симулировать различные состояние, которые могут возникать в системе, и если дедлок все же где-то возможен, предоставит детали этого бага.&lt;/p&gt;\n&lt;p&gt;Моделеру на вход подается модель состояний. Моделер проверяет, что модель состояний подходит под соответствующие поведенческие свойства.&lt;br /&gt;\nНапример, моделер может проверить модель состояний на недостатки такие как race conditions (зависимость от порядка выполнения частей кода при параллелилизме), исследуя все возможные состояния вашей модели.&lt;/p&gt;\n&lt;p&gt;Три различные фазы в проверке моделей:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Фаза моделирования (modelling phase). Модель описывается на том же языке, что и сама система. Также на этой фазе выполняются простые понятные ясные проверки (sanity checks) с простой логикой.&lt;br /&gt;\nНужны, чтобы на следующих фазах уже думать о более сложной логике.&lt;/li&gt;\n&lt;li&gt;Фаза выполнения (running phase). Моделер запущен и проверяет, как модель удовлетворяет желаемым свойствам, описанным на предыдущей фазе.&lt;/li&gt;\n&lt;li&gt;Фаза анализа (analysis phase). Эта фаза наступает тогда, когда все желаемые свойства проверены и найдены некоторые нарушения.&lt;br /&gt;\nНарушения называются контрпримерами (counterexamples). Model Checker должен предоставить описания нарушений, чтобы можно было их анализировать.&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Model Checker запускается повторно до тех пор, пока все не будет корректно работать.&lt;/p&gt;\n&lt;p&gt;Model Checking не только помогает убедиться, что система хорошо спроектированна, но также помогает понять, удовлетворяет ли система желаемым качествам и поведению, и работает так, как задумано.&lt;/p&gt;\n","meta":{"metadata":[{"name":"generator","content":"Diplodoc Platform v5.19.6"}],"vcsPath":"courses/desc/obj_oriented_design.md"},"headings":[],"title":"Название и ссылка"},"router":{"pathname":"courses/desc/obj_oriented_design","depth":3,"base":"../../"},"lang":"ru","langs":["ru"],"viewerInterface":{"toc":true,"search":true,"feedback":true}}
        </script>
        <script type="application/javascript">
            const data = document.querySelector('script#diplodoc-state');
            window.__DATA__ = JSON.parse((function unescape(string) {
                return string.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
              })(data.innerText));
            window.STATIC_CONTENT = false;
        </script>
        <script type="application/javascript" defer src="toc.js"></script>
        <script type="application/javascript" defer src="_bundle/vendor-e69d71e99c7f296b.js"></script>
        <script type="application/javascript" defer src="_bundle/react-23c48c44d4a3ad02.js"></script>
        <script type="application/javascript" defer src="_bundle/app-e70f636e61ffb694.js"></script>
        
    </body>
</html>